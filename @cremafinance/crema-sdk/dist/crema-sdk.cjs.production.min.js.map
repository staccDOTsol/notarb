{"version":3,"file":"crema-sdk.cjs.production.min.js","sources":["../src/math/liquity.ts","../src/math/tick.ts","../src/util/decimalExt.ts","../src/instructions/instruction.ts","../src/util/layout.ts","../src/state/positions.ts","../src/state/tick.ts","../src/state/tokenSwap.ts","../node_modules/regenerator-runtime/runtime.js","../src/instructions/addUserPosition.ts","../src/instructions/claim.ts","../src/instructions/depositAllTokenTypes.ts","../src/instructions/initialize.ts","../src/instructions/managerClaim.ts","../src/instructions/simulateSwap.ts","../src/instructions/swap.ts","../src/instructions/withdrawAllTokenTypes.ts","../src/util/url.ts","../src/util/transaction.ts","../src/util/token.ts","../src/tokenSwap.ts"],"sourcesContent":["import Decimal from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\n\nimport type { Tick } from \"../state\";\nimport { tick2SqrtPrice } from \".\";\n\n/**\n * Calculate liquity and another token amount when current tick is in [tickLower, tickUpper]\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param currentSqrtPrice The current sqrt price\n * @param desiredAmountSrc The src token amount\n * @param direct 0(desiredAmountSrc is TokenA), 1(desiredAmountSrc is TokenB)\n * @returns The liquity and dst token amount\n */\nexport function calculateLiquity(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountSrc: Decimal,\n  currentSqrtPrice: Decimal,\n  direct: number\n): {\n  desiredAmountDst: Decimal;\n  deltaLiquity: Decimal;\n} {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  invariant(\n    currentSqrtPrice.greaterThanOrEqualTo(lowerSqrtPrice) &&\n      currentSqrtPrice.lessThanOrEqualTo(upperSqrtPrice),\n    \"The current price must in [lowerPrice,upperPrice]\"\n  );\n  const one = new Decimal(1);\n  if (direct === 0) {\n    const deltaLiquity = desiredAmountSrc.div(\n      one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice))\n    );\n    const desiredAmountDst = deltaLiquity.mul(\n      currentSqrtPrice.sub(lowerSqrtPrice)\n    );\n    return { desiredAmountDst, deltaLiquity };\n  } else {\n    const deltaLiquity = desiredAmountSrc.div(\n      currentSqrtPrice.sub(lowerSqrtPrice)\n    );\n    const desiredAmountDst = deltaLiquity.mul(\n      one.div(currentSqrtPrice).sub(one.div(upperSqrtPrice))\n    );\n    return { desiredAmountDst, deltaLiquity };\n  }\n}\n\n/**\n * Calculate amount out of token A and token B by liquity\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param currentSqrtPrice The current sqrt price\n * @param liquity The liquity amount\n * @returns The amount of token A and token B\n */\nexport function calculateTokenAmount(\n  tickLower: number,\n  tickUpper: number,\n  liquity: Decimal,\n  currentSqrtPrice: Decimal\n): {\n  amountA: Decimal;\n  amountB: Decimal;\n} {\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  if (currentSqrtPrice.lessThan(lowerSqrtPrice)) {\n    return {\n      amountA: liquity.div(lowerSqrtPrice).sub(liquity.div(upperSqrtPrice)),\n      amountB: new Decimal(0),\n    };\n  } else if (currentSqrtPrice.greaterThan(upperSqrtPrice)) {\n    return {\n      amountA: new Decimal(0),\n      amountB: liquity.mul(upperSqrtPrice).sub(liquity.mul(lowerSqrtPrice)),\n    };\n  } else {\n    return {\n      amountA: liquity.div(currentSqrtPrice).sub(liquity.div(upperSqrtPrice)),\n      amountB: liquity.mul(currentSqrtPrice).sub(liquity.mul(lowerSqrtPrice)),\n    };\n  }\n}\n\n/**\n * Calculate liquity when current tick is less than tickLower\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param desiredAmountA The desired amount of token A\n * @returns the liquity\n */\nexport function calculateLiquityOnlyA(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountA: Decimal\n): Decimal {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  const one = new Decimal(1);\n  return desiredAmountA.div(\n    one.div(lowerSqrtPrice).sub(one.div(upperSqrtPrice))\n  );\n}\n\n/**\n * Calculate liquity when current tick is less than tickLower\n * @param tickLower The tick lower\n * @param tickUpper The tick upper\n * @param desiredAmountA The desired amount of token B\n * @returns The liquity\n */\nexport function calculateLiquityOnlyB(\n  tickLower: number,\n  tickUpper: number,\n  desiredAmountB: Decimal\n): Decimal {\n  invariant(tickLower < tickUpper, \"The tickLower must less than tickUpper\");\n  const lowerSqrtPrice = tick2SqrtPrice(tickLower);\n  const upperSqrtPrice = tick2SqrtPrice(tickUpper);\n  return desiredAmountB.div(upperSqrtPrice.sub(lowerSqrtPrice));\n}\n\nexport interface Liquity {\n  lowerTick: number;\n  upperTick: number;\n  amount: Decimal;\n}\n/**\n * Calculate the liquitys table\n * @param ticks The tick array of token swap\n * @returns The min, max of liquity, and liquitys array\n */\nexport function calculateLiquityTable(ticks: Tick[]): {\n  maxLiquity: Decimal;\n  minLiquity: Decimal;\n  liquitys: Liquity[];\n} {\n  let minLiquity = new Decimal(0);\n  let maxLiquity = new Decimal(0);\n  const liquitys: Liquity[] = [];\n  const liquity: Liquity = {\n    lowerTick: 0,\n    upperTick: 0,\n    amount: new Decimal(0),\n  };\n  for (let i = 0; i < ticks.length; i++) {\n    if (liquity.amount.equals(0)) {\n      liquity.lowerTick = ticks[i].tick;\n      liquity.amount = ticks[i].liquityNet;\n      continue;\n    }\n    liquity.upperTick = ticks[i].tick;\n    minLiquity =\n      liquity.amount.lessThan(minLiquity) || minLiquity.equals(0)\n        ? liquity.amount\n        : minLiquity;\n    maxLiquity = liquity.amount.greaterThan(maxLiquity)\n      ? liquity.amount\n      : maxLiquity;\n    liquitys.push({\n      lowerTick: liquity.lowerTick,\n      upperTick: liquity.upperTick,\n      amount: liquity.amount,\n    });\n    liquity.amount = liquity.amount.add(ticks[i].liquityNet);\n    liquity.lowerTick = ticks[i].tick;\n  }\n  return { maxLiquity, minLiquity, liquitys };\n}\n\n/**\n * Calculate max tokenAmount with sliding point.\n * @param liquity.\n * @param current sqrt price.\n * @param sliding point.\n */\nexport function calculateSlidTokenAmount(\n  tickLower: number,\n  tickUpper: number,\n  liquity: Decimal,\n  currentSqrtPrice: Decimal,\n  slid: Decimal\n): {\n  maxAmountA: Decimal;\n  minAmountA: Decimal;\n  maxAmountB: Decimal;\n  minAmountB: Decimal;\n  amountA: Decimal;\n  amountB: Decimal;\n} {\n  invariant(\n    slid.lessThan(1) && slid.greaterThan(0),\n    `Invalid slid:${slid.toString()}`\n  );\n  const maxSqrtPrice = currentSqrtPrice.mul(new Decimal(1).add(slid).sqrt());\n  const minSqrtPrice = currentSqrtPrice.mul(new Decimal(1).sub(slid).sqrt());\n  const constant = calculateTokenAmount(\n    tickLower,\n    tickUpper,\n    liquity,\n    currentSqrtPrice\n  );\n  const minRes = calculateTokenAmount(\n    tickLower,\n    tickUpper,\n    liquity,\n    minSqrtPrice\n  );\n  const maxRes = calculateTokenAmount(\n    tickLower,\n    tickUpper,\n    liquity,\n    maxSqrtPrice\n  );\n  return {\n    maxAmountA: minRes.amountA,\n    minAmountA: maxRes.amountA,\n    maxAmountB: maxRes.amountB,\n    minAmountB: minRes.amountB,\n    amountA: constant.amountA,\n    amountB: constant.amountB,\n  };\n}\n","import { Decimal } from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\n\nimport type { Tick } from \"../state\";\n\n// The max ticker\nexport const MAX_TICK = 443632;\n// export const MAX_TICK = 552648\n\n// The min ticker\nexport const MIN_TICK = -MAX_TICK;\n\n// The price pieces\n// price = pow(PIECES, TICK)\nexport const PIECES = new Decimal(\"1.0001\");\nexport const PRICE_OFFSET = new Decimal(\"1e-12\");\nexport const MAX_PRICE = PIECES.pow(MAX_TICK).add(PRICE_OFFSET);\nexport const MIN_PRICE = PIECES.pow(MIN_TICK).add(PRICE_OFFSET);\nexport const MAX_SQRT_PRICE = PIECES.pow(MAX_TICK / 2)\n  .add(PRICE_OFFSET)\n  .toDP(12);\nexport const MIN_SQRT_PRICE = PIECES.pow(MIN_TICK / 2)\n  .sub(PRICE_OFFSET)\n  .toDP(12);\n\n/**\n * Get the tick by sqrt price\n *\n * @param sqrtPrice the sqrt price\n  let afterSqrtPrice = liquity.div(amountIn.add(liquity.div(upperSqrtPrice)));\n */\nexport function sqrtPrice2Tick(sqrtPrice: Decimal): number {\n  invariant(\n    sqrtPrice.lessThanOrEqualTo(MAX_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()} Max: ${MAX_SQRT_PRICE.toString()}, too large`\n  );\n  invariant(\n    sqrtPrice.greaterThanOrEqualTo(MIN_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()}, Min: ${MIN_SQRT_PRICE.toString()}, too small`\n  );\n  return sqrtPrice.pow(2).log(PIECES).toDP(0, Decimal.ROUND_HALF_UP).toNumber();\n}\n\n/**\n * Get the sqrt price by tick\n * @param tick the tick\n * @returns the sqrt price\n */\nexport function tick2SqrtPrice(tick: number): Decimal {\n  invariant(\n    tick >= MIN_TICK && tick <= MAX_TICK,\n    `Invalid tick: ${tick}, must be in range [${MIN_TICK}, ${MAX_TICK}]`\n  );\n  return PIECES.pow(tick / 2);\n}\n\n/**\n * Get the tick by price\n * @param price the price\n * @returns the tick\n */\nexport function price2Tick(price: Decimal): number {\n  invariant(\n    price.lessThan(MAX_PRICE),\n    `Invalid price:${price.toString()} Max: ${MAX_PRICE.toString()},  too large`\n  );\n  invariant(\n    price.greaterThan(MIN_PRICE),\n    `Invalid price:${price.toString()} Min: ${MIN_PRICE.toString()}, too small`\n  );\n  return price.log(PIECES).toDP(0, Decimal.ROUND_HALF_UP).toNumber();\n}\n\n/**\n * Get the price by tick\n * @param tick the tick\n * @returns the price\n */\nexport function tick2Price(tick: number): Decimal {\n  invariant(\n    tick >= MIN_TICK && tick <= MAX_TICK,\n    `Invalid tick: ${tick}, must be in range [${MIN_TICK.toString()}, ${MAX_TICK.toString()}]`\n  );\n  return PIECES.pow(tick);\n}\n\n/**\n * Get the nearest valid tick\n * @deprecated please use {@link getNearestTickBySqrtPrice Or getNearestTickByPrice} instead\n * @param sqrtPrice the sqrt price\n * @param tickSpace the tick space\n * @param isLower is the tick is lowwer\n * @returns the tick or null\n */\nexport function getNearestTick(\n  sqrtPrice: Decimal,\n  tickSpace: number\n): number | null {\n  return getNearestTickBySqrtPrice(sqrtPrice, tickSpace);\n}\n\n/**\n * Get the nearest valid tick for positions\n * @param sqrtPrice the sqrt price\n * @param tickSpace the tick space\n * @returns the tick or null(if the tick space <= 0)\n */\nexport function getNearestTickBySqrtPrice(\n  sqrtPrice: Decimal,\n  tickSpace: number\n): number {\n  invariant(\n    tickSpace > 0 && tickSpace % 1 === 0,\n    `Invalid tickSpace:${tickSpace}`\n  );\n  invariant(\n    sqrtPrice.lessThan(MAX_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()} Max: ${MAX_SQRT_PRICE.toString()}, too large`\n  );\n  invariant(\n    sqrtPrice.greaterThan(MIN_SQRT_PRICE),\n    `Invalid sqrtPrice: ${sqrtPrice.toString()}, Min: ${MIN_SQRT_PRICE.toString()}, too small`\n  );\n  const t = sqrtPrice2Tick(sqrtPrice);\n  const m = (t - MIN_TICK) % tickSpace;\n  if (m > tickSpace / 2) {\n    return t - m + tickSpace;\n  }\n  return t - m;\n}\n\n/**\n * Get the nearest valid tick for positions\n * @param price the price\n * @param tickSpace the tick space\n * @returns the tick or null(if the tick space <= 0)\n */\nexport function getNearestTickByPrice(\n  price: Decimal,\n  tickSpace: number\n): number {\n  invariant(\n    tickSpace > 0 && tickSpace % 1 === 0,\n    `Invalid tickSpace:${tickSpace}`\n  );\n  invariant(\n    price.lessThan(MAX_PRICE),\n    `Invalid price:${price.toString()} Max: ${MAX_PRICE.toString()},  too large`\n  );\n  invariant(\n    price.greaterThan(MIN_PRICE),\n    `Invalid price:${price.toString()} Min: ${MIN_PRICE.toString()}, too small`\n  );\n  const t = price2Tick(price);\n  const m = (t - MIN_TICK) % tickSpace;\n  if (m > tickSpace / 2) {\n    return t - m + tickSpace;\n  }\n  return t - m;\n}\n\n/**\n *\n * @param ticks The tick array of token swap\n * @param currentSqrtPrice The current sqrt price of token swap\n * @param fee The fee rate of token swap\n * @param currentLiquity The current liquity of token swap\n * @param amountIn The amount in of token A\n * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n */\nexport function calculateSwapA2B(\n  ticks: Tick[],\n  currentSqrtPrice: Decimal,\n  fee: Decimal,\n  currentLiquity: Decimal,\n  amountIn: Decimal\n): {\n  amountOut: Decimal;\n  amountUsed: Decimal;\n  feeUsed: Decimal;\n  afterPrice: Decimal;\n  afterLiquity: Decimal;\n} {\n  invariant(amountIn.greaterThan(new Decimal(0)), \"invalid amount in\");\n  invariant(\n    currentLiquity.greaterThanOrEqualTo(new Decimal(0)),\n    \"invalid liquity\"\n  );\n  invariant(ticks.length > 0, \"the ticks is empty\");\n  //let currentTick = sqrtPrice2Tick(currentSqrtPrice);\n  invariant(currentSqrtPrice > ticks[0].tickPrice, \"out of ticks\");\n  let liquity = currentLiquity;\n  let out = new Decimal(0);\n  let remind = amountIn;\n  let remindWithFee = new Decimal(0);\n  let feeUsed = new Decimal(0);\n  let amountUsed = new Decimal(0);\n  for (let i = ticks.length - 1; i >= 0; i--) {\n    if (liquity.equals(new Decimal(0))) {\n      currentSqrtPrice = ticks[i].tickPrice.sub(PRICE_OFFSET);\n      liquity = liquity.sub(ticks[i].liquityNet);\n      //upperSqrtPrice = ticks[i].tickPrice;\n      continue;\n    }\n    if (currentSqrtPrice < ticks[i].tickPrice) {\n      continue;\n    }\n    const upperSqrtPrice = currentSqrtPrice;\n    const lowerSqrtPrice = ticks[i].tickPrice;\n    const maxAmountIn = maxAmountA(lowerSqrtPrice, currentSqrtPrice, liquity);\n    const fullStepFee = maxAmountIn.mul(fee).toDP(0, Decimal.ROUND_DOWN);\n    if (remind.lessThan(fullStepFee)) {\n      remindWithFee = remind;\n    } else {\n      remindWithFee = remind.sub(fullStepFee);\n    }\n\n    if (maxAmountIn.greaterThanOrEqualTo(remindWithFee)) {\n      remindWithFee = remind\n        .mul(new Decimal(1).sub(fee))\n        .toDP(0, Decimal.ROUND_UP);\n      const { amountOut, afterSqrtPrice } = swapA2B(\n        upperSqrtPrice,\n        liquity,\n        remindWithFee\n      );\n      amountUsed = amountUsed.add(remind);\n      feeUsed = feeUsed.add(remind.sub(remindWithFee));\n      return {\n        amountOut: out.add(amountOut),\n        amountUsed,\n        feeUsed,\n        afterPrice: afterSqrtPrice,\n        afterLiquity: liquity,\n      };\n    } else {\n      remind = remindWithFee.sub(maxAmountIn);\n      amountUsed = amountUsed.add(maxAmountIn).add(fullStepFee);\n      feeUsed = feeUsed.add(fullStepFee);\n      out = out.add(maxAmountB(lowerSqrtPrice, upperSqrtPrice, liquity));\n      liquity = liquity.sub(ticks[i].liquityNet);\n      currentSqrtPrice = ticks[i].tickPrice.sub(PRICE_OFFSET);\n      //upperSqrtPrice = ticks[i].tickPrice;\n    }\n  }\n  return {\n    amountOut: out,\n    amountUsed,\n    feeUsed,\n    afterPrice: currentSqrtPrice,\n    afterLiquity: liquity,\n  };\n}\n\n/**\n *\n * @param ticks The tick array of token swap\n * @param currentSqrtPrice The current sqrt price of token swap\n * @param fee The fee rate of token swap\n * @param currentLiquity The current liquity of token swap\n * @param amountIn The amount in of token B\n * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n */\nexport function calculateSwapB2A(\n  ticks: Tick[],\n  currentSqrtPrice: Decimal,\n  fee: Decimal,\n  currentLiquity: Decimal,\n  amountIn: Decimal\n): {\n  amountOut: Decimal;\n  amountUsed: Decimal;\n  feeUsed: Decimal;\n  afterPrice: Decimal;\n  afterLiquity: Decimal;\n} {\n  invariant(amountIn.greaterThan(new Decimal(0)), \"invalid amount in\");\n  invariant(\n    currentLiquity.greaterThanOrEqualTo(new Decimal(0)),\n    \"invalid liquity\"\n  );\n  invariant(ticks.length > 0, \"the ticks is empty\");\n  //let currentTick = sqrtPrice2Tick(currentSqrtPrice);\n  invariant(\n    currentSqrtPrice.lessThan(ticks[ticks.length - 1].tickPrice),\n    \"out of ticks\"\n  );\n  let liquity = currentLiquity;\n  let out = new Decimal(0);\n  let remind = amountIn;\n  let remindWithFee = new Decimal(0);\n  let amountUsed = new Decimal(0);\n  let feeUsed = new Decimal(0);\n  for (let i = 0; i < ticks.length; i++) {\n    if (liquity.equals(new Decimal(0))) {\n      currentSqrtPrice = ticks[i].tickPrice.add(PRICE_OFFSET);\n      liquity = liquity.add(ticks[i].liquityNet);\n      continue;\n    }\n    if (currentSqrtPrice > ticks[i].tickPrice) {\n      continue;\n    }\n    const upperSqrtPrice = ticks[i].tickPrice;\n    const maxAmountIn = maxAmountB(currentSqrtPrice, upperSqrtPrice, liquity);\n    const fullStepFee = maxAmountIn.mul(fee).toDP(0, Decimal.ROUND_DOWN);\n    if (remind.lessThan(fullStepFee)) {\n      remindWithFee = remind;\n    } else {\n      remindWithFee = remind.sub(fullStepFee);\n    }\n    if (maxAmountIn.greaterThanOrEqualTo(remindWithFee)) {\n      remindWithFee = remind\n        .mul(new Decimal(1).sub(fee))\n        .toDP(0, Decimal.ROUND_UP);\n      const { amountOut, afterSqrtPrice } = swapB2A(\n        currentSqrtPrice,\n        liquity,\n        remindWithFee\n      );\n      amountUsed = amountUsed.add(remind);\n      feeUsed = feeUsed.add(remind.sub(remindWithFee));\n      return {\n        amountOut: out.add(amountOut),\n        feeUsed,\n        amountUsed,\n        afterPrice: afterSqrtPrice.pow(2),\n        afterLiquity: liquity,\n      };\n    } else {\n      remind = remindWithFee.sub(maxAmountIn);\n      amountUsed = amountUsed.add(maxAmountIn).add(fullStepFee);\n      feeUsed = feeUsed.add(fullStepFee);\n      out = out.add(maxAmountA(currentSqrtPrice, upperSqrtPrice, liquity));\n      liquity = liquity.add(ticks[i].liquityNet);\n      currentSqrtPrice = ticks[i].tickPrice.add(PRICE_OFFSET);\n    }\n  }\n  return {\n    amountOut: out,\n    amountUsed,\n    feeUsed,\n    afterPrice: currentSqrtPrice,\n    afterLiquity: liquity,\n  };\n}\n\n/** @internal */\nexport function maxAmountA(\n  lowerSqrtPrice: Decimal,\n  upperSqrtPrice: Decimal,\n  liquity: Decimal\n): Decimal {\n  return liquity\n    .div(lowerSqrtPrice)\n    .toDP(0, Decimal.ROUND_DOWN)\n    .sub(liquity.div(upperSqrtPrice).toDP(0, Decimal.ROUND_DOWN));\n}\n\n/** @internal */\nexport function maxAmountB(\n  lowerSqrtPrice: Decimal,\n  upperSqrtPrice: Decimal,\n  liquity: Decimal\n): Decimal {\n  return liquity\n    .mul(upperSqrtPrice.sub(lowerSqrtPrice))\n    .toDP(0, Decimal.ROUND_DOWN);\n}\n\n/** @internal */\nexport function swapA2B(\n  upperSqrtPrice: Decimal,\n  liquity: Decimal,\n  amountIn: Decimal\n): { amountOut: Decimal; afterSqrtPrice: Decimal } {\n  const afterSqrtPrice = liquity.div(amountIn.add(liquity.div(upperSqrtPrice)));\n  const delta_increase = amountIn.add(\n    liquity.div(upperSqrtPrice).toDP(0, Decimal.ROUND_DOWN)\n  );\n  const out = liquity\n    .mul(upperSqrtPrice)\n    .toDP(0, Decimal.ROUND_DOWN)\n    .sub(liquity.mul(liquity).div(delta_increase).toDP(0, Decimal.ROUND_DOWN));\n  return { amountOut: out, afterSqrtPrice };\n}\n\n/** @internal */\nexport function swapB2A(\n  lowerSqrtPrice: Decimal,\n  liquity: Decimal,\n  amountIn: Decimal\n): { amountOut: Decimal; afterSqrtPrice: Decimal } {\n  const afterSqrtPrice = amountIn.div(liquity).add(lowerSqrtPrice);\n  const delta_increase = amountIn.add(\n    liquity.mul(lowerSqrtPrice).toDP(0, Decimal.ROUND_DOWN)\n  );\n  const out = liquity\n    .div(lowerSqrtPrice)\n    .toDP(0, Decimal.ROUND_DOWN)\n    .sub(liquity.mul(liquity).div(delta_increase).toDP(0, Decimal.ROUND_DOWN));\n  return { amountOut: out, afterSqrtPrice };\n}\n","import BN from \"bn.js\";\nimport Decimal from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\n\nDecimal.config({\n  precision: 64,\n  rounding: Decimal.ROUND_DOWN,\n  toExpNeg: -64,\n  toExpPos: 64,\n});\n\nconst TEN = new Decimal(10);\nconst P64 = new Decimal(2).pow(64);\nconst MAX_INT64 = P64.div(2).sub(1);\nconst MIN_INT64 = P64.div(2).neg();\nconst MAX_UINT64 = P64.sub(1);\nconst MAX_INT128 = P64.pow(63).sub(1);\nconst MIN_INT128 = MAX_INT128.neg();\nconst MAX_UINT128 = P64.pow(64).sub(1);\nconst MAX_PRECISION = 40;\n\nexport class DecimalExt {\n  /**\n   * New a Decimal from a int64 buffer\n   * @param buffer The buffer\n   * @param precision The pricision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static from64Buffer(buffer: Buffer, precision = 0): Decimal {\n    invariant(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    console.log(buffer);\n\n    if (buffer[7] >= 0x80) {\n      const ss = [];\n      for (const v of buffer) {\n        ss.push(`00${Math.abs(~v & 0xff).toString(16)}`.slice(-2));\n      }\n      const bn = new BN(ss.join(\"\"), 16, \"le\").add(new BN(1)).neg();\n      return new Decimal(bn.toString()).div(TEN.pow(precision));\n    }\n    return new Decimal(new BN(buffer, \"le\").toString()).div(TEN.pow(precision));\n  }\n\n  /**\n   * New a Decimal from a uint64 buffer\n   * @param buffer The buffer\n   * @param precision The precision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static fromU64Buffer(buffer: Buffer, precision = 0): Decimal {\n    invariant(buffer.length === 8, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    return new Decimal(new BN(buffer, 16, \"le\").toString()).div(\n      TEN.pow(precision)\n    );\n  }\n\n  /**\n   * New a Decimal from a int128 buffer\n   * @param buffer The buffer\n   * @param precision The pricision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static from128Buffer(buffer: Buffer, precision = 0): Decimal {\n    invariant(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n\n    if (buffer[15] >= 0x80) {\n      const ss = [];\n      for (const v of buffer) {\n        ss.push(`00${Math.abs(~v & 0xff).toString(16)}`.slice(-2));\n      }\n      const bn = new BN(ss.join(\"\"), 16, \"le\").add(new BN(1)).neg();\n      return new Decimal(bn.toString()).div(TEN.pow(precision));\n    }\n    return new Decimal(new BN(buffer, \"le\").toString()).div(TEN.pow(precision));\n  }\n\n  /**\n   * New a Decimal from a uint128 buffer\n   * @param buffer The buffer\n   * @param precision The precision\n   * @returns The Decimal value, the result will be div 10^precision\n   */\n  static fromU128Buffer(buffer: Buffer, precision = 0): Decimal {\n    invariant(buffer.length === 16, `Invalid buffer length: ${buffer.length}`);\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    return new Decimal(new BN(buffer, \"le\").toString()).div(TEN.pow(precision));\n  }\n\n  /**\n   * Convert a Decimal value to int64 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static to64Buffer(v: Decimal, precision = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(MIN_INT64) && v.lessThanOrEqualTo(MAX_INT64),\n      `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`\n    );\n    const bn = new BN(v.toString());\n    if (bn.isNeg()) {\n      const buffer = bn.add(new BN(1)).toBuffer(\"le\", 8);\n      buffer.forEach(function (item, index, input) {\n        input[index] = ~item & 0xff;\n      });\n      return buffer;\n    } else {\n      return bn.toBuffer(\"le\", 8);\n    }\n  }\n\n  /**\n   * Convert a Decimal value to uint64 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static toU64Buffer(v: Decimal, precision = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(0) && v.lessThanOrEqualTo(MAX_UINT64),\n      `Invalid v: ${v.toString()} to uint64 buffer with precision: ${precision}`\n    );\n    return new BN(v.toString()).toBuffer(\"le\", 8);\n  }\n\n  /**\n   * Convert a Decimal value to int128 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static to128Buffer(v: Decimal, precision = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(MIN_INT128) && v.lessThanOrEqualTo(MAX_INT128),\n      `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`\n    );\n    const bn = new BN(v.toString());\n    if (bn.isNeg()) {\n      const buffer = bn.add(new BN(1)).toBuffer(\"le\", 16);\n      buffer.forEach(function (item, index, input) {\n        input[index] = ~item & 0xff;\n      });\n      return buffer;\n    } else {\n      return bn.toBuffer(\"le\", 16);\n    }\n  }\n\n  /**\n   * Convert a Decimal value to uint128 buffer\n   * @param v The Decimal value\n   * @param precision The precision\n   * @returns The buffer, the result will be mul 10^precision\n   */\n  static toU128Buffer(v: Decimal, precision = 0): Buffer {\n    invariant(\n      Math.abs(precision) < MAX_PRECISION,\n      `Invalid precision: ${precision}`\n    );\n    v = v.mul(TEN.pow(precision)).round();\n    invariant(\n      v.greaterThanOrEqualTo(0) && v.lessThanOrEqualTo(MAX_UINT128),\n      `Invalid v: ${v.toString()} to int128 buffer with precision: ${precision}`\n    );\n    return new BN(v.toString()).toBuffer(\"le\", 16);\n  }\n}\n","/** @internal */\nexport enum TokenSwapInstruction {\n  Initialize = 0,\n  Swap = 1,\n  DepositAllTokenTypes = 2,\n  WithdrawAllTokenTypes = 3,\n  Claim = 4,\n  ManagerClaim = 5,\n  AddUserPosition = 6,\n  UpdateFee = 7,\n  SimulateSwap = 8,\n}\n","import type { Blob, Layout } from \"@solana/buffer-layout\";\nimport { blob } from \"@solana/buffer-layout\";\nimport type { AccountInfo } from \"@solana/web3.js\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport { DecimalExt } from \"./decimalExt\";\n\nexport type Parser<T> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) =>\n  | {\n      pubkey: PublicKey;\n      info: AccountInfo<Buffer>;\n      data: T;\n    }\n  | undefined;\n\n/** @internal */\nexport interface EncodeDecode<T> {\n  decode: (buffer: Buffer, offset?: number) => T;\n  encode: (src: T, buffer: Buffer, offset?: number) => number;\n}\n\n/** @internal */\nexport const encodeDecode = <T>(layout: Layout<T>): EncodeDecode<T> => {\n  const decode = layout.decode.bind(layout);\n  const encode = layout.encode.bind(layout);\n  return { decode, encode };\n};\n\nexport const publicKey = (property = \"publicKey\"): Layout<PublicKey> => {\n  const layout = blob(32, property);\n  const { encode, decode } = encodeDecode(layout);\n\n  const publicKeyLayout = layout as Layout<unknown> as Layout<PublicKey>;\n\n  publicKeyLayout.decode = (buffer: Buffer, offset: number) => {\n    const src = decode(buffer, offset);\n    return new PublicKey(src);\n  };\n\n  publicKeyLayout.encode = (\n    publicKey: PublicKey,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = publicKey.toBuffer();\n    return encode(src, buffer, offset);\n  };\n\n  return publicKeyLayout;\n};\n\nexport const uint64 = (property = \"uint128\"): Blob => {\n  return blob(8, property);\n};\n\nexport const int64 = (property = \"uint128\"): Blob => {\n  return blob(8, property);\n};\n\nexport const int128 = (property = \"uint128\"): Blob => {\n  return blob(16, property);\n};\n\nexport const uint128 = (property = \"uint128\"): Blob => {\n  return blob(16, property);\n};\n\nexport const decimal64 = (\n  property = \"uint64\",\n  precision = 0\n): Layout<Decimal> => {\n  const layout = blob(8, property);\n  //const { encode, decode } = encodeDecode(layout);\n  const decimal64Layout = layout as Layout<unknown> as Layout<Decimal>;\n\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n\n  decimal64Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    return DecimalExt.from64Buffer(src, precision);\n  };\n\n  decimal64Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.to64Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimal64Layout;\n};\n\nexport const decimalU64 = (\n  property = \"uint64\",\n  precision = 0\n): Layout<Decimal> => {\n  const layout = blob(8, property);\n  //const { encode, decode } = encodeDecode(layout)\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n  const decimalU64Layout = layout as Layout<unknown> as Layout<Decimal>;\n\n  decimalU64Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    return DecimalExt.fromU64Buffer(src, precision);\n  };\n\n  decimalU64Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.toU64Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimalU64Layout;\n};\n\nexport const decimal128 = (\n  property = \"uint64\",\n  precision = 0\n): Layout<Decimal> => {\n  const layout = blob(16, property);\n  //const { encode, decode } = encodeDecode(layout);\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n  const decimal128Layout = layout as Layout<unknown> as Layout<Decimal>;\n\n  decimal128Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    return DecimalExt.from128Buffer(src, precision);\n  };\n\n  decimal128Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.to128Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimal128Layout;\n};\n\nexport const decimalU128 = (\n  property = \"uint64\",\n  precision = 0\n): Layout<Decimal> => {\n  const layout = blob(16, property);\n  //const { encode, decode } = encodeDecode(layout);\n  const _decode = layout.decode.bind(layout);\n  const _encode = layout.encode.bind(layout);\n  const decimalU128Layout = layout as Layout<unknown> as Layout<Decimal>;\n\n  decimalU128Layout.decode = (buffer: Buffer, offset: number) => {\n    const src = Buffer.from(_decode(buffer, offset));\n    const val = DecimalExt.fromU128Buffer(src, precision);\n    return val;\n  };\n\n  decimalU128Layout.encode = (\n    decimal: Decimal,\n    buffer: Buffer,\n    offset: number\n  ) => {\n    const src = DecimalExt.toU128Buffer(decimal, precision);\n    return _encode(src, buffer, offset);\n  };\n\n  return decimalU128Layout;\n};\n","import { blob, s32, seq, struct, u8 } from \"@solana/buffer-layout\";\nimport type { AccountInfo, PublicKey } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport type { Parser } from \"../util/layout\";\nimport { decimalU128, publicKey } from \"../util/layout\";\n\nexport const POSITIONS_ACCOUNT_SIZE = 360000;\nexport const POSITIONS_ACCOUNT_TYPE = 2;\n\nexport interface Position {\n  nftTokenId: PublicKey;\n  lowerTick: number;\n  upperTick: number;\n  liquity: Decimal;\n  feeGrowthInsideALast: Decimal;\n  feeGrowthInsideBLast: Decimal;\n  tokenAFee: Decimal;\n  tokenBFee: Decimal;\n}\n\nexport interface PositionsAccount {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  positions: Position[];\n}\n\n/* @internal */\nexport interface PositionsAccountDataFlat {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  dataFlat: Uint8Array;\n}\n\nexport const PositionLayout = struct<Position>(\n  [\n    publicKey(\"nftTokenId\"),\n    s32(\"lowerTick\"),\n    s32(\"upperTick\"),\n    decimalU128(\"liquity\"),\n    decimalU128(\"feeGrowthInsideALast\", 16),\n    decimalU128(\"feeGrowthInsideBLast\", 16),\n    decimalU128(\"tokenAFee\", 16),\n    decimalU128(\"tokenBFee\", 16),\n  ],\n  \"position\"\n);\n\nexport const PositionsAccountLayout = struct<PositionsAccountDataFlat>(\n  [\n    u8(\"swapVersion\"),\n    publicKey(\"tokenSwapKey\"),\n    u8(\"accountType\"),\n    s32(\"len\"),\n    blob(POSITIONS_ACCOUNT_SIZE - 38, \"dataFlat\"),\n  ],\n  \"positionsAccount\"\n);\n\nexport const MAX_ACCOUNT_POSITION_LENGTH = Math.floor(\n  (POSITIONS_ACCOUNT_SIZE - 38) / PositionLayout.span\n);\n\nexport const isPositionsAccount = (info: AccountInfo<Buffer>): boolean => {\n  return info.data.readUInt8(33) === POSITIONS_ACCOUNT_TYPE;\n};\n\nexport const parsePositionsAccount: Parser<PositionsAccount> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  if (!isPositionsAccount(info)) return;\n\n  const buffer = Buffer.from(info.data);\n  const { swapVersion, tokenSwapKey, accountType, len, dataFlat } =\n    PositionsAccountLayout.decode(buffer);\n\n  const positionSpan = len * PositionLayout.span;\n  const positionsBuffer = dataFlat.slice(0, positionSpan);\n  const positions = seq(PositionLayout, len).decode(positionsBuffer);\n\n  const positionsAccount: PositionsAccount = {\n    swapVersion,\n    tokenSwapKey,\n    accountType,\n    len,\n    positions,\n  };\n\n  return {\n    pubkey,\n    info,\n    data: positionsAccount,\n  };\n};\n","import { blob, s32, seq, struct, u8 } from \"@solana/buffer-layout\";\nimport type { AccountInfo, PublicKey } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport type { Parser } from \"../util/layout\";\nimport { decimal128, decimalU128, publicKey } from \"../util/layout\";\n\nexport const TICKS_ACCOUNT_SIZE = 504000;\nexport const TICKS_ACCOUNT_TYPE = 1;\n\nexport interface Tick {\n  tick: number;\n  tickPrice: Decimal;\n  liquityGross: Decimal;\n  liquityNet: Decimal;\n  feeGrowthOutside0: Decimal;\n  feeGrowthOutside1: Decimal;\n}\n\nexport interface TicksAccount {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  ticks: Tick[];\n}\n\n/* @internal */\nexport interface TicksAccountDataFlat {\n  swapVersion: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  len: number;\n  dataFlat: Uint8Array;\n}\n\nexport const TickLayout = struct<Tick>(\n  [\n    s32(\"tick\"),\n    decimalU128(\"tickPrice\", 12),\n    decimalU128(\"liquityGross\"),\n    decimal128(\"liquityNet\"),\n    decimalU128(\"feeGrowthOutside0\", 16),\n    decimalU128(\"feeGrowthOutside1\", 16),\n  ],\n  \"tickInfo\"\n);\n\nexport const isTicksAccount = (info: AccountInfo<Buffer>): boolean => {\n  return info.data.readUInt8(33) === TICKS_ACCOUNT_TYPE;\n};\n\nexport const parseTicksAccount: Parser<TicksAccount> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  if (!isTicksAccount(info)) return;\n\n  const Layout = struct<TicksAccountDataFlat>(\n    [\n      u8(\"swapVersion\"),\n      publicKey(\"tokenSwapKey\"),\n      u8(\"accountType\"),\n      s32(\"len\"),\n      blob(info.data.length - 38, \"dataFlat\"),\n    ],\n    \"ticksAccount\"\n  );\n\n  const buffer = Buffer.from(info.data);\n  const { swapVersion, tokenSwapKey, accountType, len, dataFlat } =\n    Layout.decode(buffer);\n\n  const tickSpan = len * TickLayout.span;\n  const ticksBuffer = dataFlat.slice(0, tickSpan);\n  const ticks = seq(TickLayout, len).decode(ticksBuffer);\n\n  const ticksAccount: TicksAccount = {\n    swapVersion,\n    tokenSwapKey,\n    accountType,\n    len,\n    ticks,\n  };\n\n  return {\n    pubkey,\n    info,\n    data: ticksAccount,\n  };\n};\n","import { struct, u8, u32 } from \"@solana/buffer-layout\";\nimport type { AccountInfo, PublicKey } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport type { Parser } from \"../util/layout\";\nimport { decimalU64, decimalU128, publicKey } from \"../util/layout\";\n\nexport const TOKEN_SWAP_ACCOUNT_TYPE = 0;\n\nexport interface TokenSwapAccount {\n  version: number;\n  tokenSwapKey: PublicKey;\n  accountType: number;\n  isInitialized: number;\n  nonce: number;\n  tokenProgramId: PublicKey;\n  manager: PublicKey;\n  managerTokenA: PublicKey;\n  managerTokenB: PublicKey;\n  swapTokenA: PublicKey;\n  swapTokenB: PublicKey;\n  tokenAMint: PublicKey;\n  tokenBMint: PublicKey;\n  ticksKey: PublicKey;\n  positionsKey: PublicKey;\n  curveType: number;\n  fee: Decimal;\n  managerFee: Decimal;\n  tickSpace: number;\n  currentSqrtPrice: Decimal;\n  currentLiquity: Decimal;\n  feeGrowthGlobal0: Decimal;\n  feeGrowthGlobal1: Decimal;\n  managerFeeA: Decimal;\n  managerFeeB: Decimal;\n}\n\nexport const TokenSwapAccountLayout = struct<TokenSwapAccount>(\n  [\n    u8(\"version\"),\n    publicKey(\"tokenSwapKey\"),\n    u8(\"accountType\"),\n    u8(\"isInitialized\"),\n    u8(\"nonce\"),\n    publicKey(\"tokenProgramId\"),\n    publicKey(\"manager\"),\n    publicKey(\"managerTokenA\"),\n    publicKey(\"managerTokenB\"),\n    publicKey(\"swapTokenA\"),\n    publicKey(\"swapTokenB\"),\n    publicKey(\"tokenAMint\"),\n    publicKey(\"tokenBMint\"),\n    publicKey(\"ticksKey\"),\n    publicKey(\"positionsKey\"),\n    u8(\"curveType\"),\n    decimalU64(\"fee\", 12),\n    decimalU64(\"managerFee\", 12),\n    u32(\"tickSpace\"),\n    decimalU128(\"currentSqrtPrice\", 12),\n    decimalU128(\"currentLiquity\"),\n    decimalU128(\"feeGrowthGlobal0\", 16),\n    decimalU128(\"feeGrowthGlobal1\", 16),\n    decimalU128(\"managerFeeA\"),\n    decimalU128(\"managerFeeB\"),\n  ],\n  \"tokenSwapAccount\"\n);\n\nexport const TOKEN_SWAP_ACCOUNT_SIZE = TokenSwapAccountLayout.span;\n\nexport const isTokenSwapAccount = (info: AccountInfo<Buffer>): boolean => {\n  return info.data.readUInt8(33) === TOKEN_SWAP_ACCOUNT_TYPE;\n};\n\nexport const parseTokenSwapAccount: Parser<TokenSwapAccount> = (\n  pubkey: PublicKey,\n  info: AccountInfo<Buffer>\n) => {\n  if (!isTokenSwapAccount(info)) {\n    return;\n  }\n\n  const buffer = Buffer.from(info.data);\n  const tokenSwapAccount = TokenSwapAccountLayout.decode(buffer);\n\n  return {\n    pubkey,\n    info,\n    data: tokenSwapAccount,\n  };\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { struct, u8 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\n\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n}\n\nconst DataLayout = struct<Data>([u8(\"instruction\")]);\n\nexport const addUserPositionInstruction = (\n  programId: PublicKey,\n  authority: PublicKey,\n  positionsKey: PublicKey\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.AddUserPosition,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: programId, isSigner: false, isWritable: false },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, u8 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  positionIndex: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"positionIndex\"),\n]);\n\nexport const claimInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey,\n  nftMint: PublicKey,\n  nftUser: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  positionIndex: Decimal\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.Claim,\n      positionIndex,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: false },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: nftMint, isSigner: false, isWritable: false },\n    { pubkey: nftUser, isSigner: false, isWritable: false },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: false },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { s32, struct, u8 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport { decimalU64, decimalU128 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  isNewPosition: number;\n  liquityAmount: Decimal;\n  tickLower: number;\n  tickUpper: number;\n  maximumTokenA: Decimal;\n  maximumTokenB: Decimal;\n  positionIndex: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  u8(\"isNewPosition\"),\n  decimalU128(\"liquityAmount\"),\n  s32(\"tickLower\"),\n  s32(\"tickUpper\"),\n  decimalU64(\"maximumTokenA\"),\n  decimalU64(\"maximumTokenB\"),\n  decimalU64(\"positionIndex\"),\n]);\n\nexport const depositAllTokenTypesInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  nftMint: PublicKey,\n  nftUser: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  isNewPosition: number,\n  tickLower: number,\n  tickUpper: number,\n  liquityAmount: Decimal,\n  maximumTokenA: Decimal,\n  maximumTokenB: Decimal,\n  positionIndex: Decimal\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.DepositAllTokenTypes,\n      isNewPosition,\n      liquityAmount,\n      tickLower,\n      tickUpper,\n      maximumTokenA,\n      maximumTokenB,\n      positionIndex,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: nftMint, isSigner: false, isWritable: true },\n    { pubkey: nftUser, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, u8, u32 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport Decimal from \"decimal.js\";\n\nimport { decimalU64, decimalU128 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  nonce: number;\n  curveType: number;\n  fee: Decimal;\n  managerFee: Decimal;\n  tickSpace: number;\n  currentSqrtPrice: Decimal;\n  currentLiquity: Decimal;\n  feeGrowthGlobal0: Decimal;\n  feeGrowthGlobal1: Decimal;\n  managerFeeA: Decimal;\n  managerFeeB: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  u8(\"nonce\"),\n  u8(\"curveType\"),\n  decimalU64(\"fee\", 12),\n  decimalU64(\"managerFee\", 12),\n  u32(\"tickSpace\"),\n  decimalU128(\"currentSqrtPrice\", 12),\n  decimalU128(\"currentLiquity\"),\n  decimalU128(\"feeGrowthGlobal0\"),\n  decimalU128(\"feeGrowthGlobal1\"),\n  decimalU128(\"managerFeeA\"),\n  decimalU128(\"managerFeeB\"),\n]);\n\nexport const initializeInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  manager: PublicKey,\n  managerTokenA: PublicKey,\n  managerTokenB: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  nonce: number,\n  curveType: number,\n  fee: Decimal,\n  managerFee: Decimal,\n  tickSpace: number,\n  currentSqrtPrice: Decimal\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.Initialize,\n      nonce,\n      curveType,\n      fee,\n      managerFee,\n      tickSpace,\n      currentSqrtPrice,\n      currentLiquity: new Decimal(0),\n      feeGrowthGlobal0: new Decimal(0),\n      feeGrowthGlobal1: new Decimal(0),\n      managerFeeA: new Decimal(0),\n      managerFeeB: new Decimal(0),\n    },\n    data\n  );\n\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: manager, isSigner: false, isWritable: false },\n    { pubkey: managerTokenA, isSigner: false, isWritable: false },\n    { pubkey: managerTokenB, isSigner: false, isWritable: false },\n    { pubkey: swapTokenA, isSigner: false, isWritable: false },\n    { pubkey: swapTokenB, isSigner: false, isWritable: false },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, u8 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\n\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n}\n\nconst DataLayout = struct<Data>([u8(\"instruction\")]);\n\nexport const managerClaimInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.ManagerClaim,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, u8 } from \"@solana/buffer-layout\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  amountIn: Decimal;\n  // minimumAmountOut: Decimal,\n  direction: number;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"amountIn\"),\n  // decimalU64(\"minimumAmountOut\"),\n  u8(\"direction\"),\n]);\n\nexport const simulateSwapInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  ticksKey: PublicKey,\n  amountIn: Decimal,\n  // minimumAmountOut: Decimal,\n  direction: number\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.SimulateSwap,\n      amountIn,\n      // minimumAmountOut,\n      direction,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, u8 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  amountIn: Decimal;\n  minimumAmountOut: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"amountIn\"),\n  decimalU64(\"minimumAmountOut\"),\n]);\n\nexport const swapInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  userSource: PublicKey,\n  userDestination: PublicKey,\n  swapSource: PublicKey,\n  swapDestination: PublicKey,\n  ticksKey: PublicKey,\n  amountIn: Decimal,\n  minimumAmountOut: Decimal\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.Swap,\n      amountIn,\n      minimumAmountOut,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: userSource, isSigner: false, isWritable: true },\n    { pubkey: userDestination, isSigner: false, isWritable: true },\n    { pubkey: swapSource, isSigner: false, isWritable: true },\n    { pubkey: swapDestination, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","import { struct, u8 } from \"@solana/buffer-layout\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type { PublicKey } from \"@solana/web3.js\";\nimport { TransactionInstruction } from \"@solana/web3.js\";\nimport type Decimal from \"decimal.js\";\n\nimport { decimalU64 } from \"../util/layout\";\nimport { TokenSwapInstruction } from \"./instruction\";\n\ninterface Data {\n  instruction: number;\n  liquityAmount: Decimal;\n  minimumTokenA: Decimal;\n  minimumTokenB: Decimal;\n  positionIndex: Decimal;\n}\n\nconst DataLayout = struct<Data>([\n  u8(\"instruction\"),\n  decimalU64(\"liquityAmount\"),\n  decimalU64(\"minimumTokenA\"),\n  decimalU64(\"minimumTokenB\"),\n  decimalU64(\"positionIndex\"),\n]);\n\nexport const withdrawAllTokenTypesInstruction = (\n  programId: PublicKey,\n  tokenSwapKey: PublicKey,\n  authority: PublicKey,\n  userTransferAuthority: PublicKey,\n  swapTokenA: PublicKey,\n  swapTokenB: PublicKey,\n  userTokenA: PublicKey,\n  userTokenB: PublicKey,\n  nftMint: PublicKey,\n  nftUser: PublicKey,\n  ticksKey: PublicKey,\n  positionsKey: PublicKey,\n  liquityAmount: Decimal,\n  minimumTokenA: Decimal,\n  minimumTokenB: Decimal,\n  positionIndex: Decimal\n): TransactionInstruction => {\n  const data = Buffer.alloc(DataLayout.span);\n  DataLayout.encode(\n    {\n      instruction: TokenSwapInstruction.WithdrawAllTokenTypes,\n      liquityAmount,\n      minimumTokenA,\n      minimumTokenB,\n      positionIndex,\n    },\n    data\n  );\n  const keys = [\n    { pubkey: tokenSwapKey, isSigner: false, isWritable: true },\n    { pubkey: authority, isSigner: false, isWritable: false },\n    { pubkey: userTransferAuthority, isSigner: true, isWritable: false },\n    { pubkey: nftMint, isSigner: false, isWritable: true },\n    { pubkey: nftUser, isSigner: false, isWritable: true },\n    { pubkey: swapTokenA, isSigner: false, isWritable: true },\n    { pubkey: swapTokenB, isSigner: false, isWritable: true },\n    { pubkey: userTokenA, isSigner: false, isWritable: true },\n    { pubkey: userTokenB, isSigner: false, isWritable: true },\n    { pubkey: ticksKey, isSigner: false, isWritable: true },\n    { pubkey: positionsKey, isSigner: false, isWritable: true },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data,\n  });\n};\n","/* eslint-disable @typescript-eslint/restrict-plus-operands */\n// To connect to a public cluster, set `export LIVE=1` in your\n// environment. By default, `LIVE=1` will connect to the devnet cluster.\n\nimport type { Cluster } from \"@solana/web3.js\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport dotenv from \"dotenv\";\n\nfunction chooseCluster(): Cluster | undefined {\n  dotenv.config();\n  if (!process.env.LIVE) return;\n  switch (process.env.CLUSTER) {\n    case \"devnet\":\n    case \"testnet\":\n    case \"mainnet-beta\": {\n      return process.env.CLUSTER;\n    }\n  }\n  throw 'Unknown cluster \"' + process.env.CLUSTER + '\", check the .env file';\n}\n\nexport const cluster = chooseCluster();\n\nexport const url =\n  process.env.RPC_URL ||\n  (process.env.LIVE ? clusterApiUrl(cluster, false) : \"http://localhost:8899\");\n\nexport const urlTls =\n  process.env.RPC_URL ||\n  (process.env.LIVE ? clusterApiUrl(cluster, true) : \"http://localhost:8899\");\n\nexport const walletUrl =\n  process.env.WALLET_URL || \"https://solana-example-webwallet.herokuapp.com/\";\n","import type {\n  Connection,\n  Signer,\n  Transaction,\n  TransactionSignature,\n} from \"@solana/web3.js\";\nimport { sendAndConfirmTransaction as realSendAndConfirmTransaction } from \"@solana/web3.js\";\n\n/**\n * Send and confirm trnasaction with default option\n * @param conn The connection to use\n * @param transaction The transaction\n * @param signers The signers array\n * @returns\n */\nexport async function sendAndConfirmTransaction(\n  conn: Connection,\n  transaction: Transaction,\n  ...signers: Signer[]\n): Promise<TransactionSignature> {\n  return realSendAndConfirmTransaction(conn, transaction, signers, {\n    skipPreflight: false,\n    commitment: \"recent\",\n    preflightCommitment: \"recent\",\n  });\n}\n","/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\nimport type { AccountInfo } from \"@solana/spl-token\";\nimport {\n  AccountLayout,\n  ASSOCIATED_TOKEN_PROGRAM_ID,\n  Token,\n  TOKEN_PROGRAM_ID,\n  u64,\n} from \"@solana/spl-token\";\nimport type {\n  AccountInfo as BaseAccountInfo,\n  Connection,\n  TransactionInstruction,\n} from \"@solana/web3.js\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport invariant from \"tiny-invariant\";\n\n/**\n * Get a authority token account address\n * @param tokenMint The mint of token\n * @param owner The owner associated token address\n * @returns\n */\nexport async function getAssociatedTokenAddress(\n  tokenMint: PublicKey,\n  owner: PublicKey\n): Promise<PublicKey> {\n  return await Token.getAssociatedTokenAddress(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    tokenMint,\n    owner,\n    true\n  );\n}\n\n/**\n * Get a create associated token account instruction\n * @param tokenMint The mint of token\n * @param owner The owner associated token address\n * @param authority The authority token account address\n * @param payer The pays for transaction\n * @returns\n */\nexport function createAssociatedTokenAccountInstruction(\n  tokenMint: PublicKey,\n  associatedAccount: PublicKey,\n  owner: PublicKey,\n  payer: PublicKey\n): TransactionInstruction {\n  return Token.createAssociatedTokenAccountInstruction(\n    ASSOCIATED_TOKEN_PROGRAM_ID,\n    TOKEN_PROGRAM_ID,\n    tokenMint,\n    associatedAccount,\n    owner,\n    payer\n  );\n}\n\n/**\n * Get the token account info by address\n * @param conn The connection to use\n * @param address The token account address\n * @returns\n */\nexport async function getTokenAccount(\n  conn: Connection,\n  address: PublicKey\n): Promise<AccountInfo> {\n  const account = await conn.getAccountInfo(address);\n  invariant(\n    account?.data !== null,\n    `The token account:${address.toBase58()} data is null`\n  );\n  invariant(account !== null, \"the account is null\");\n  const accountInfo = parseTokenAccount(account);\n  accountInfo.address = address;\n  return accountInfo;\n}\n\n/**\n * Get the token accounts by owner\n * @param conn The connection to use\n * @param owner The owner address\n * @returns The token accounts\n */\nexport async function getTokenAccounts(\n  conn: Connection,\n  owner: PublicKey\n): Promise<AccountInfo[]> {\n  const accounts = await conn.getTokenAccountsByOwner(owner, {\n    programId: TOKEN_PROGRAM_ID,\n  });\n  const accountInfos: AccountInfo[] = [];\n  for (let i = 0; i < accounts.value.length; i++) {\n    const { pubkey, account } = accounts.value[i];\n    invariant(\n      account?.data !== null,\n      `The token account:${pubkey.toBase58()} data is null`\n    );\n    const accountInfo = parseTokenAccount(account);\n    accountInfo.address = pubkey;\n    accountInfos.push(accountInfo);\n  }\n  return accountInfos;\n}\n\nexport function parseTokenAccountData(data: Buffer): AccountInfo {\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}\n\nexport function parseTokenAccount(\n  account: BaseAccountInfo<Buffer>\n): AccountInfo {\n  invariant(account?.data !== null, `The account data is null`);\n  const accountInfo = AccountLayout.decode(account?.data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n\n  return accountInfo;\n}\n","import { MintLayout, Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport type {\n  Connection,\n  GetProgramAccountsConfig,\n  Signer,\n  TransactionSignature,\n} from \"@solana/web3.js\";\nimport {\n  Keypair,\n  PublicKey,\n  SystemProgram,\n  Transaction,\n} from \"@solana/web3.js\";\nimport Decimal from \"decimal.js\";\nimport invariant from \"tiny-invariant\";\n\nimport {\n  addUserPositionInstruction,\n  claimInstruction,\n  depositAllTokenTypesInstruction,\n  initializeInstruction,\n  managerClaimInstruction,\n  simulateSwapInstruction,\n  swapInstruction,\n  withdrawAllTokenTypesInstruction,\n} from \"./instructions\";\nimport {\n  calculateLiquity,\n  calculateLiquityOnlyA,\n  calculateLiquityOnlyB,\n  calculateSwapA2B,\n  calculateSwapB2A,\n  calculateTokenAmount,\n  getNearestTickByPrice,\n  sqrtPrice2Tick,\n} from \"./math\";\nimport type { Tick, TokenSwapAccount } from \"./state\";\nimport {\n  isPositionsAccount,\n  isTicksAccount,\n  isTokenSwapAccount,\n  MAX_ACCOUNT_POSITION_LENGTH,\n  parsePositionsAccount,\n  parseTicksAccount,\n  parseTokenSwapAccount,\n  POSITIONS_ACCOUNT_SIZE,\n  TICKS_ACCOUNT_SIZE,\n  TOKEN_SWAP_ACCOUNT_SIZE,\n} from \"./state\";\nimport { sendAndConfirmTransaction } from \"./util\";\nimport {\n  createAssociatedTokenAccountInstruction,\n  getAssociatedTokenAddress,\n  getTokenAccounts,\n} from \"./util/token\";\n\nexport const INIT_KEY = new PublicKey(\"11111111111111111111111111111111\");\n\nexport interface PositionInfo {\n  positionsKey: PublicKey;\n  index: Decimal;\n  positionId: PublicKey;\n  lowerTick: number;\n  upperTick: number;\n  liquity: Decimal;\n  feeGrowthInsideALast: Decimal;\n  feeGrowthInsideBLast: Decimal;\n  tokenAFee: Decimal;\n  tokenBFee: Decimal;\n}\n\nDecimal.config({\n  precision: 64,\n  rounding: Decimal.ROUND_HALF_DOWN,\n  toExpNeg: -64,\n  toExpPos: 64,\n});\n\n/**\n * The token swap class\n */\nexport class TokenSwap {\n  conn: Connection;\n  programId: PublicKey = INIT_KEY;\n  tokenSwapKey: PublicKey = INIT_KEY;\n  payer: Signer | null;\n  authority: PublicKey = INIT_KEY;\n  isLoaded = false;\n  currentTick = 0;\n  tokenSwapInfo: TokenSwapAccount = {\n    tokenSwapKey: INIT_KEY,\n    accountType: 0,\n    version: 0,\n    isInitialized: 0,\n    nonce: 0,\n    tokenProgramId: TOKEN_PROGRAM_ID,\n    manager: INIT_KEY,\n    managerTokenA: INIT_KEY,\n    managerTokenB: INIT_KEY,\n    swapTokenA: INIT_KEY,\n    swapTokenB: INIT_KEY,\n    tokenAMint: INIT_KEY,\n    tokenBMint: INIT_KEY,\n    ticksKey: INIT_KEY,\n    positionsKey: INIT_KEY,\n    curveType: 0,\n    fee: new Decimal(0),\n    managerFee: new Decimal(0),\n    tickSpace: 0,\n    currentSqrtPrice: new Decimal(0),\n    currentLiquity: new Decimal(0),\n    feeGrowthGlobal0: new Decimal(0),\n    feeGrowthGlobal1: new Decimal(0),\n    managerFeeA: new Decimal(0),\n    managerFeeB: new Decimal(0),\n  };\n  ticks: Tick[] = [];\n  positions: Map<string, PositionInfo>;\n  positionsKeys: Map<PublicKey, number>;\n\n  /**\n   * The constructor of TokenSwap\n   * @param conn The connection to use\n   * @param programId The token swap program id\n   * @param tokenSwapKey The token swap key\n   * @param payer The default pays for the transaction\n   */\n  constructor(\n    conn: Connection,\n    programId: PublicKey,\n    tokenSwapKey: PublicKey,\n    payer: Signer | null\n  ) {\n    this.conn = conn;\n    this.tokenSwapKey = tokenSwapKey;\n    this.programId = programId;\n    this.payer = payer;\n    this.positions = new Map();\n    this.positionsKeys = new Map();\n  }\n\n  /**\n   * Set the default payer\n   * @returns\n   */\n  setDefaultPayer(payer: Signer) {\n    this.payer = payer;\n  }\n\n  /**\n   * Load the token swap info\n   */\n  async load(): Promise<TokenSwap> {\n    const config: GetProgramAccountsConfig = {\n      encoding: \"base64\",\n      filters: [\n        {\n          memcmp: {\n            offset: 1,\n            bytes: this.tokenSwapKey.toBase58(),\n          },\n        },\n      ],\n    };\n    const accounts = await this.conn.getProgramAccounts(this.programId, config);\n    accounts.map((item) => {\n      if (isTokenSwapAccount(item.account)) {\n        const info = parseTokenSwapAccount(item.pubkey, item.account);\n        invariant(\n          info?.data !== undefined,\n          \"The token swap account parse failed\"\n        );\n        this.tokenSwapInfo = info.data;\n      } else if (isTicksAccount(item.account)) {\n        const info = parseTicksAccount(item.pubkey, item.account);\n        invariant(info?.data !== undefined, \"The tick account parse failed\");\n        this.ticks = info.data.ticks;\n      } else if (isPositionsAccount(item.account)) {\n        const info = parsePositionsAccount(item.pubkey, item.account);\n        invariant(\n          info?.data !== undefined,\n          \"The position account data parse failed\"\n        );\n        this.positionsKeys.set(item.pubkey, info.data.positions.length);\n        for (let i = 0; i < info.data.positions.length; i++) {\n          const p = info.data.positions[i];\n          this.positions.set(p.nftTokenId.toBase58(), {\n            positionsKey: item.pubkey,\n            index: new Decimal(i),\n            positionId: p.nftTokenId,\n            lowerTick: p.lowerTick,\n            upperTick: p.upperTick,\n            liquity: p.liquity,\n            feeGrowthInsideALast: p.feeGrowthInsideALast,\n            feeGrowthInsideBLast: p.feeGrowthInsideBLast,\n            tokenAFee: p.tokenAFee,\n            tokenBFee: p.tokenBFee,\n          });\n        }\n      } else {\n        console.log(\n          \"the account:%s length:%d unkown\",\n          item.pubkey.toString(),\n          item.account.data.length\n        );\n      }\n    });\n    if (this.authority.toString() === INIT_KEY.toString()) {\n      const [authority] = await PublicKey.findProgramAddress(\n        [this.tokenSwapKey.toBuffer()],\n        this.programId\n      );\n      this.authority = authority;\n    }\n    this.isLoaded = true;\n    this.currentTick = sqrtPrice2Tick(this.tokenSwapInfo.currentSqrtPrice);\n    return this;\n  }\n\n  /**\n   * Create a new token swap\n   * @param conn The connection to use\n   * @param programId The token swap program id\n   * @param payer Pays for the transaction\n   * @param tokenAMint The token A mint\n   * @param tokenBMint The token B mint\n   * @param manager The manager\n   * @param fee The fee of token swap\n   * @param managerFee The manager(protocol) fee of token swap\n   * @param tickSpace The tick space\n   * @param initializePrice The initilized price of token swap\n   * @param payer The pays for the transaction\n   */\n  static async createTokenSwap(\n    conn: Connection,\n    programId: PublicKey,\n    tokenAMint: PublicKey,\n    tokenBMint: PublicKey,\n    manager: PublicKey,\n    fee: Decimal,\n    managerFee: Decimal,\n    tickSpace: number,\n    initializePrice: Decimal,\n    payer: Signer,\n    isDebug = false\n  ): Promise<TokenSwap> {\n    // generate account create instruction that token swap need\n    const tokenSwapAccount = Keypair.generate();\n    const ticksAccount = Keypair.generate();\n    const positionsAccount = Keypair.generate();\n    const [authority, nonce] = await PublicKey.findProgramAddress(\n      [tokenSwapAccount.publicKey.toBuffer()],\n      programId\n    );\n    const ticksAccountLamports = await conn.getMinimumBalanceForRentExemption(\n      TICKS_ACCOUNT_SIZE\n    );\n    const positionsAccountLarports =\n      await conn.getMinimumBalanceForRentExemption(POSITIONS_ACCOUNT_SIZE);\n    const tokenSwapAccountLamports =\n      await conn.getMinimumBalanceForRentExemption(TOKEN_SWAP_ACCOUNT_SIZE);\n    const transaction = new Transaction().add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: tokenSwapAccount.publicKey,\n        lamports: tokenSwapAccountLamports,\n        space: TOKEN_SWAP_ACCOUNT_SIZE,\n        programId: programId,\n      }),\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: ticksAccount.publicKey,\n        lamports: ticksAccountLamports,\n        space: TICKS_ACCOUNT_SIZE,\n        programId: programId,\n      }),\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: positionsAccount.publicKey,\n        lamports: positionsAccountLarports,\n        space: POSITIONS_ACCOUNT_SIZE,\n        programId: programId,\n      })\n    );\n\n    // generate create token swap authority token account instruction\n    const swapTokenA = await getAssociatedTokenAddress(tokenAMint, authority);\n    const swapTokenB = await getAssociatedTokenAddress(tokenBMint, authority);\n    transaction.add(\n      createAssociatedTokenAccountInstruction(\n        tokenAMint,\n        swapTokenA,\n        authority,\n        payer.publicKey\n      ),\n      createAssociatedTokenAccountInstruction(\n        tokenBMint,\n        swapTokenB,\n        authority,\n        payer.publicKey\n      )\n    );\n\n    // generate token swap initialize instruction\n    const currentSqrtPrice = initializePrice.sqrt();\n    const tokenA = new Token(conn, tokenAMint, TOKEN_PROGRAM_ID, payer);\n    const tokenB = new Token(conn, tokenBMint, TOKEN_PROGRAM_ID, payer);\n    const managerTokenA = await tokenA.getOrCreateAssociatedAccountInfo(\n      manager\n    );\n    const managerTokenB = await tokenB.getOrCreateAssociatedAccountInfo(\n      manager\n    );\n\n    const curveType = 0;\n    transaction.add(\n      initializeInstruction(\n        programId,\n        tokenSwapAccount.publicKey,\n        authority,\n        manager,\n        managerTokenA.address,\n        managerTokenB.address,\n        swapTokenA,\n        swapTokenB,\n        ticksAccount.publicKey,\n        positionsAccount.publicKey,\n        nonce,\n        curveType,\n        fee,\n        managerFee,\n        tickSpace,\n        currentSqrtPrice\n      )\n    );\n\n    // send and confirm transaction\n    const tx = await sendAndConfirmTransaction(\n      conn,\n      transaction,\n      payer,\n      tokenSwapAccount,\n      ticksAccount,\n      positionsAccount\n    );\n    if (isDebug) {\n      console.log(tx);\n    }\n\n    return await new TokenSwap(\n      conn,\n      programId,\n      tokenSwapAccount.publicKey,\n      payer\n    ).load();\n  }\n\n  /**\n   *\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param lowerTick The lower tick\n   * @param upperTick The upper tick\n   * @param liquity The liquity amount\n   * @param maximumAmountA The maximum amount of Token A\n   * @param maximumAmountB The maximum amount of Token B\n   * @param userTransferAuthroity The pays for the transaction\n   * @returns\n   */\n  async mintPosition(\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    lowerTick: number,\n    upperTick: number,\n    liquity: Decimal,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal,\n    userTransferAuthroity: Signer,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (this.isLoaded) {\n      await this.load();\n    }\n    invariant(\n      lowerTick < upperTick,\n      \"The lowerTick must be less than upperTick\"\n    );\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n\n    // Generate create position nft token instructions\n    const nftMintAccount = Keypair.generate();\n    const nftUser = await getAssociatedTokenAddress(\n      nftMintAccount.publicKey,\n      payer.publicKey\n    );\n    const accountLamports = await Token.getMinBalanceRentForExemptAccount(\n      this.conn\n    );\n    const positionsKey = this.choosePosition();\n    invariant(positionsKey !== null, \"The position account space is full\");\n    const transaction = new Transaction();\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: nftMintAccount.publicKey,\n        lamports: accountLamports,\n        space: MintLayout.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        nftMintAccount.publicKey,\n        0,\n        this.authority,\n        null\n      ),\n      createAssociatedTokenAccountInstruction(\n        nftMintAccount.publicKey,\n        nftUser,\n        payer.publicKey,\n        payer.publicKey\n      )\n    );\n\n    // Generate mint positon instruction\n    transaction.add(\n      depositAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        userTransferAuthroity.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        nftMintAccount.publicKey,\n        nftUser,\n        this.tokenSwapInfo.ticksKey,\n        positionsKey,\n        0,\n        lowerTick,\n        upperTick,\n        liquity,\n        maximumAmountA,\n        maximumAmountB,\n        new Decimal(0)\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(\n      this.conn,\n      transaction,\n      payer,\n      userTransferAuthroity,\n      nftMintAccount\n    );\n  }\n\n  /**\n   * Increase liquity on a exist position\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param lowerTick The lower tick\n   * @param upperTick The upper tick\n   * @param liquity The liquity amount\n   * @param maximumAmountA The maximum of token A\n   * @param maximumAmountB The maximum of token B\n   * @returns\n   */\n  async increaseLiquity(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    liquity: Decimal,\n    maximumAmountA: Decimal,\n    maximumAmountB: Decimal,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `Position:${positionId.toString()} not found`\n    );\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n\n    const nftToken = new Token(this.conn, positionId, TOKEN_PROGRAM_ID, payer);\n    const nftUser = await nftToken.getAccountInfo(\n      await getAssociatedTokenAddress(nftToken.publicKey, payer.publicKey)\n    );\n    invariant(\n      nftUser.amount.toNumber() === 1,\n      `You not hold this position:${nftToken.publicKey.toBase58()}`\n    );\n\n    // Generate mint positon instruction\n    const transaction = new Transaction();\n    transaction.add(\n      depositAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        userTokenA,\n        userTokenB,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        positionId,\n        nftUser.address,\n        this.tokenSwapInfo.ticksKey,\n        positionInfo.positionsKey,\n        1,\n        positionInfo.lowerTick,\n        positionInfo.upperTick,\n        liquity,\n        maximumAmountA,\n        maximumAmountB,\n        positionInfo.index\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   * Decrease liquity, after decrease if liquity amount is zero the position will be remove\n   * @param positionId The position id (nft mint address)\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param liquity The liquity amount\n   * @param minimumAmountA The minimum amount of token A want recv\n   * @param minimumAmountB The minimum amount of token b want recv\n   * @param userAuthroity The pays for the transaction\n   * @returns\n   */\n  async decreaseLiquity(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    liquity: Decimal,\n    minimumAmountA: Decimal,\n    minimumAmountB: Decimal,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `Position:${positionId.toString()} not found`\n    );\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    const nftToken = new Token(this.conn, positionId, TOKEN_PROGRAM_ID, payer);\n    const nftUser = await nftToken.getAccountInfo(\n      await getAssociatedTokenAddress(nftToken.publicKey, payer.publicKey)\n    );\n    invariant(\n      nftUser.amount.toNumber() === 1,\n      `You not hold this position:${nftToken.publicKey.toBase58()}`\n    );\n\n    // Create withdrawAllTokenTypes instruction\n    const transaction = new Transaction().add(\n      withdrawAllTokenTypesInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB,\n        positionId,\n        nftUser.address,\n        this.tokenSwapInfo.ticksKey,\n        positionInfo.positionsKey,\n        liquity,\n        minimumAmountA,\n        minimumAmountB,\n        positionInfo.index\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   *\n   * @param userSource The token that user want swap out\n   * @param userDestination The token that user want swap in\n   * @param direct 0-A swap B, 1-B swap A\n   * @param amountIn The amount in\n   * @param minimumAmountOut The minimum amount out\n   * @param userTransactionAuthority Account delegated to transfer user's tokens\n   * @returns\n   */\n  async swap(\n    userSource: PublicKey,\n    userDestination: PublicKey,\n    direct: number,\n    amountIn: Decimal,\n    minimumAmountOut: Decimal,\n    userTransferAuthority: Signer,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    const { swapSrc, swapDst } =\n      direct === 1\n        ? {\n            swapSrc: this.tokenSwapInfo.swapTokenA,\n            swapDst: this.tokenSwapInfo.swapTokenB,\n          }\n        : {\n            swapSrc: this.tokenSwapInfo.swapTokenB,\n            swapDst: this.tokenSwapInfo.swapTokenA,\n          };\n\n    const transaction = new Transaction().add(\n      swapInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        userTransferAuthority.publicKey,\n        userSource,\n        userDestination,\n        swapSrc,\n        swapDst,\n        this.tokenSwapInfo.ticksKey,\n        amountIn,\n        minimumAmountOut\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(\n      this.conn,\n      transaction,\n      payer,\n      userTransferAuthority\n    );\n  }\n\n  async simulateSwap(amountIn: Decimal, direction: number, payer: Signer) {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const transaction = new Transaction().add(\n      simulateSwapInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.tokenSwapInfo.ticksKey,\n        amountIn,\n        direction\n      )\n    );\n\n    const res = await this.conn.simulateTransaction(transaction, [payer]);\n    console.log(res);\n  }\n\n  /**\n   *\n   * Collect fee from specified position\n   * @param positionID The NFT token public key of position\n   * @param userTokenA The user address of token A\n   * @param userTokenB The user address of token B\n   * @param userAuthroity The pays for the transaction\n   * @returns\n   */\n  async collect(\n    positionId: PublicKey,\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `Position:${positionId.toString()} not found`\n    );\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    const nftToken = new Token(this.conn, positionId, TOKEN_PROGRAM_ID, payer);\n    const nftUser = await nftToken.getAccountInfo(\n      await getAssociatedTokenAddress(nftToken.publicKey, payer.publicKey)\n    );\n    invariant(\n      nftUser.amount.toNumber() === 1,\n      `You not hold this position:${nftToken.publicKey.toBase58()}`\n    );\n\n    const transaction = new Transaction().add(\n      claimInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        this.tokenSwapInfo.swapTokenB,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB,\n        positionId,\n        nftUser.address,\n        this.tokenSwapInfo.ticksKey,\n        positionInfo.positionsKey,\n        positionInfo.index\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   * Collect the manager fee\n   * @param userTokenA The manager address of token A\n   * @param userTokenB The manager address of token B\n   * @param userAuthroity The pays for the transaction\n   * @returns\n   */\n  async managerCollect(\n    userTokenA: PublicKey,\n    userTokenB: PublicKey,\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    const transaction = new Transaction().add(\n      managerClaimInstruction(\n        this.programId,\n        this.tokenSwapKey,\n        this.authority,\n        payer.publicKey,\n        this.tokenSwapInfo.swapTokenA,\n        this.tokenSwapInfo.swapTokenB,\n        userTokenA,\n        userTokenB\n      )\n    );\n\n    // send and confirm transaction\n    return await sendAndConfirmTransaction(this.conn, transaction, payer);\n  }\n\n  /**\n   * Add a positions account for token swap\n   * @param payer The pays for transaction\n   * @returns\n   */\n  async addPositionsAccount(\n    payer: Signer | null = null\n  ): Promise<TransactionSignature | null> {\n    if (!this.isLoaded) {\n      await this.load();\n    }\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    const positionsAccount = Keypair.generate();\n    const lamports = await this.conn.getMinimumBalanceForRentExemption(\n      POSITIONS_ACCOUNT_SIZE\n    );\n    const transaction = new Transaction().add(\n      SystemProgram.createAccount({\n        fromPubkey: payer.publicKey,\n        newAccountPubkey: positionsAccount.publicKey,\n        lamports,\n        space: POSITIONS_ACCOUNT_SIZE,\n        programId: this.programId,\n      }),\n      addUserPositionInstruction(\n        this.programId,\n        this.authority,\n        positionsAccount.publicKey\n      )\n    );\n\n    return await sendAndConfirmTransaction(\n      this.conn,\n      transaction,\n      payer,\n      positionsAccount\n    );\n  }\n\n  async approve(\n    userToken: PublicKey,\n    tokenMint: PublicKey,\n    amount: Decimal,\n    authority: Signer,\n    payer: Signer | null = null\n  ): Promise<void> {\n    payer = payer !== null ? payer : this.payer;\n    invariant(payer !== null, \"The payer is null\");\n    const token = new Token(this.conn, tokenMint, TOKEN_PROGRAM_ID, payer);\n    await token.approve(\n      userToken,\n      authority.publicKey,\n      payer,\n      [],\n      amount.toNumber()\n    );\n  }\n\n  /**\n   * Get user's positions\n   * @param owner The owner of position\n   * @returns The positions list\n   */\n  async getUserPositions(\n    owner: PublicKey | undefined = undefined\n  ): Promise<PositionInfo[] | null> {\n    invariant(this.isLoaded, \"The token swap not load\");\n    owner = owner !== undefined ? owner : this.payer?.publicKey;\n    invariant(owner !== undefined, \"The owner is undefined\");\n    const tokenAccounts = await getTokenAccounts(this.conn, owner);\n    const positions: PositionInfo[] = [];\n    for (let i = 0; i < tokenAccounts.length; i++) {\n      const position = this.positions.get(tokenAccounts[i].mint.toBase58());\n      if (position !== undefined) {\n        positions.push(position);\n      }\n    }\n    return positions;\n  }\n\n  /**\n   * Calculate the liquity and token A amount, when the token swap currentTick < upperTick\n   * @param tickLower The lower tick\n   * @param tickUpper the upper tick\n   * @param desiredAmountA The desired token A amount\n   * @returns\n   */\n  calculateLiquityByTokenA(\n    tickLower: number,\n    tickUpper: number,\n    desiredAmountA: Decimal\n  ): { desiredAmountB: Decimal; liquity: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      this.currentTick <= tickUpper,\n      \"The current price must less than lower price\"\n    );\n    if (this.currentTick < tickLower) {\n      return {\n        desiredAmountB: new Decimal(0),\n        liquity: calculateLiquityOnlyA(tickLower, tickUpper, desiredAmountA),\n      };\n    } else {\n      const res = calculateLiquity(\n        tickLower,\n        tickUpper,\n        desiredAmountA,\n        this.tokenSwapInfo.currentSqrtPrice,\n        0\n      );\n      return {\n        desiredAmountB: res.desiredAmountDst,\n        liquity: res.deltaLiquity,\n      };\n    }\n  }\n\n  /**\n   * Calculate the liquity and token B amount, when the token swap currentTick < upperTick\n   * @param tickLower The lower tick\n   * @param tickUpper the upper tick\n   * @param desiredAmountA The desired token B amount\n   * @returns\n   */\n  calculateLiquityByTokenB(\n    tickLower: number,\n    tickUpper: number,\n    desiredAmountB: Decimal\n  ): { desiredAmountA: Decimal; liquity: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    invariant(\n      this.currentTick >= tickLower,\n      \"The current price must less than lower price\"\n    );\n    if (this.currentTick < tickUpper) {\n      return {\n        desiredAmountA: new Decimal(0),\n        liquity: calculateLiquityOnlyB(tickLower, tickUpper, desiredAmountB),\n      };\n    } else {\n      const res = calculateLiquity(\n        tickLower,\n        tickUpper,\n        desiredAmountB,\n        this.tokenSwapInfo.currentSqrtPrice,\n        1\n      );\n      return {\n        desiredAmountA: res.desiredAmountDst,\n        liquity: res.deltaLiquity,\n      };\n    }\n  }\n\n  /**\n   * Calculate the position current value\n   * @param positionId The position id\n   * @returns The amount of token A and token B\n   */\n  calculatePositionValue(positionId: PublicKey): {\n    liquity: Decimal;\n    amountA: Decimal;\n    amountB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    const { amountA, amountB } = calculateTokenAmount(\n      positionInfo.lowerTick,\n      positionInfo.upperTick,\n      positionInfo.liquity,\n      this.tokenSwapInfo.currentSqrtPrice\n    );\n    return {\n      liquity: positionInfo.liquity,\n      amountA,\n      amountB,\n    };\n  }\n\n  /**\n   * prepare calculate collect amount of token A and B\n   * @param positionId The position id\n   * @returns the amount of token A and B\n   */\n  preCollect(positionId: PublicKey): { amountA: Decimal; amountB: Decimal } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const positionInfo = this.getPositionInfo(positionId);\n    invariant(\n      positionInfo !== undefined,\n      `The position:${positionId.toBase58()} not found`\n    );\n    let lowerTick: Tick | null = null;\n    let upperTick: Tick | null = null;\n    for (let i = 0; i < this.ticks.length; i++) {\n      if (this.ticks[i].tick === positionInfo.lowerTick) {\n        lowerTick = this.ticks[i];\n      }\n      if (this.ticks[i].tick === positionInfo.upperTick) {\n        upperTick = this.ticks[i];\n      }\n    }\n    invariant(\n      lowerTick !== null,\n      `The position lower tick:${positionInfo.lowerTick} not found`\n    );\n    invariant(\n      upperTick !== null,\n      `The position upper tick:${positionInfo.upperTick} not found`\n    );\n\n    let lowerFeeOutSideA = new Decimal(0);\n    let lowerFeeOutSideB = new Decimal(0);\n    let upperFeeOutSideA = new Decimal(0);\n    let upperFeeOutSideB = new Decimal(0);\n    const currentSqrtPrice = this.tokenSwapInfo.currentSqrtPrice;\n\n    if (lowerTick.tickPrice.lessThan(currentSqrtPrice)) {\n      lowerFeeOutSideA = lowerTick.feeGrowthOutside0;\n      lowerFeeOutSideB = lowerTick.feeGrowthOutside1;\n    } else {\n      lowerFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(\n        lowerTick.feeGrowthOutside0\n      );\n      lowerFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(\n        lowerTick.feeGrowthOutside1\n      );\n    }\n\n    if (upperTick.tickPrice.lessThan(currentSqrtPrice)) {\n      upperFeeOutSideA = this.tokenSwapInfo.feeGrowthGlobal0.sub(\n        upperTick.feeGrowthOutside0\n      );\n      upperFeeOutSideB = this.tokenSwapInfo.feeGrowthGlobal1.sub(\n        upperTick.feeGrowthOutside1\n      );\n    } else {\n      upperFeeOutSideA = upperTick.feeGrowthOutside0;\n      upperFeeOutSideB = upperTick.feeGrowthOutside1;\n    }\n\n    return {\n      amountA: this.tokenSwapInfo.feeGrowthGlobal0\n        .sub(lowerFeeOutSideA)\n        .sub(upperFeeOutSideA)\n        .sub(positionInfo.feeGrowthInsideALast)\n        .mul(positionInfo.liquity)\n        .add(positionInfo.tokenAFee),\n      amountB: this.tokenSwapInfo.feeGrowthGlobal1\n        .sub(lowerFeeOutSideB)\n        .sub(upperFeeOutSideB)\n        .sub(positionInfo.feeGrowthInsideBLast)\n        .mul(positionInfo.liquity)\n        .add(positionInfo.tokenBFee),\n    };\n  }\n\n  /**\n   * Prepare calculate A swap B\n   * @param amountIn The amount input of token A\n   * @returns amountOut:The amount out of token B, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n   */\n  preSwapA(amountIn: Decimal): {\n    amountOut: Decimal;\n    amountUsed: Decimal;\n    feeUsed: Decimal;\n    afterLiquity: Decimal;\n    impactA: Decimal;\n    impactB: Decimal;\n    transactionPriceA: Decimal;\n    transactionPriceB: Decimal;\n    afterPriceA: Decimal;\n    afterPriceB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const res = calculateSwapA2B(\n      this.ticks,\n      this.tokenSwapInfo.currentSqrtPrice,\n      this.tokenSwapInfo.fee,\n      this.tokenSwapInfo.currentLiquity,\n      amountIn\n    );\n    const currentPriceA = this.tokenSwapInfo.currentSqrtPrice.pow(2);\n    const currentPriceB = new Decimal(1).div(currentPriceA);\n    const transactionPriceA = res.amountOut.div(res.amountUsed);\n    const transactionPriceB = res.amountUsed.div(res.amountOut);\n    const impactA = transactionPriceA\n      .sub(currentPriceA)\n      .div(currentPriceA)\n      .abs();\n    const impactB = transactionPriceB\n      .sub(currentPriceB)\n      .div(currentPriceB)\n      .abs();\n\n    const afterPriceA = res.afterPrice.pow(2);\n    const afterPriceB = new Decimal(1).div(afterPriceA);\n\n    return {\n      amountOut: res.amountOut,\n      amountUsed: res.amountUsed,\n      feeUsed: res.feeUsed,\n      afterPriceA,\n      afterPriceB,\n      afterLiquity: res.afterLiquity,\n      impactA,\n      impactB,\n      transactionPriceA,\n      transactionPriceB,\n    };\n  }\n\n  /**\n   * Prepare calculate B swap A\n   * @param amountIn The amount input of token B\n   * @returns amountOut:The amount out of token A, amountUsed:The used of amountIn, afterPrice:The price after calculate, afterLiquity: The liquity after calculate\n   */\n  preSwapB(amountIn: Decimal): {\n    amountOut: Decimal;\n    amountUsed: Decimal;\n    feeUsed: Decimal;\n    afterLiquity: Decimal;\n    impactA: Decimal;\n    impactB: Decimal;\n    transactionPriceA: Decimal;\n    transactionPriceB: Decimal;\n    afterPriceA: Decimal;\n    afterPriceB: Decimal;\n  } {\n    invariant(this.isLoaded, \"The token swap not load\");\n    const res = calculateSwapB2A(\n      this.ticks,\n      this.tokenSwapInfo.currentSqrtPrice,\n      this.tokenSwapInfo.fee,\n      this.tokenSwapInfo.currentLiquity,\n      amountIn\n    );\n    const currentPriceA = this.tokenSwapInfo.currentSqrtPrice.pow(2);\n    const currentPriceB = new Decimal(1).div(currentPriceA);\n    const transactionPriceA = res.amountUsed.div(res.amountOut);\n    const transactionPriceB = res.amountOut.div(res.amountUsed);\n    const impactA = transactionPriceA\n      .sub(currentPriceA)\n      .div(currentPriceA)\n      .abs();\n    const impactB = transactionPriceB\n      .sub(currentPriceB)\n      .div(currentPriceB)\n      .abs();\n    const afterPriceA = res.afterPrice.pow(2);\n    const afterPriceB = new Decimal(1).div(afterPriceA);\n\n    return {\n      amountOut: res.amountOut,\n      amountUsed: res.amountUsed,\n      feeUsed: res.feeUsed,\n      afterLiquity: res.afterLiquity,\n      impactA,\n      impactB,\n      transactionPriceA,\n      transactionPriceB,\n      afterPriceA,\n      afterPriceB,\n    };\n  }\n\n  /**\n   * Get nearest tick by price\n   * @param price The price\n   * @returns The tick\n   */\n  getNearestTickByPrice(price: Decimal): number {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return getNearestTickByPrice(price, this.tokenSwapInfo.tickSpace);\n  }\n\n  /* @internal */\n  getPositionInfo(positionId: PublicKey): PositionInfo | undefined {\n    invariant(this.isLoaded, \"The token swap not load\");\n    return this.positions.get(positionId.toBase58());\n  }\n\n  /* @internal */\n  choosePosition(): PublicKey | null {\n    invariant(this.isLoaded, \"The token swap not load\");\n    for (const [key, val] of this.positionsKeys) {\n      if (val < MAX_ACCOUNT_POSITION_LENGTH) {\n        return key;\n      }\n    }\n    return null;\n  }\n\n  /* for debug */\n  log() {\n    const payer =\n      this.payer !== null ? this.payer.publicKey.toBase58() : \"null\";\n    console.log(\n      JSON.stringify(\n        {\n          programId: this.programId.toString(),\n          tokenSwapKey: this.tokenSwapKey.toString(),\n          payer: payer,\n          authority: this.authority.toString(),\n          currentTick: this.currentTick,\n          currentPrice: this.tokenSwapInfo.currentSqrtPrice.pow(2).toString(),\n          tokenSwapInfo: {\n            accountType: this.tokenSwapInfo.accountType,\n            version: this.tokenSwapInfo.version,\n            isInitialized: this.tokenSwapInfo.isInitialized,\n            nonce: this.tokenSwapInfo.nonce,\n            manager: this.tokenSwapInfo.manager.toString(),\n            managerTokenA: this.tokenSwapInfo.managerTokenA.toString(),\n            managerTokenB: this.tokenSwapInfo.managerTokenB.toString(),\n            swapTokenA: this.tokenSwapInfo.swapTokenA.toString(),\n            swapTokenB: this.tokenSwapInfo.swapTokenB.toString(),\n            tokenAMint: this.tokenSwapInfo.tokenAMint.toString(),\n            tokenBMint: this.tokenSwapInfo.tokenBMint.toString(),\n            ticksKey: this.tokenSwapInfo.ticksKey.toString(),\n            positionsKey: this.tokenSwapInfo.positionsKey.toString(),\n            curveType: this.tokenSwapInfo.curveType,\n            fee: this.tokenSwapInfo.fee,\n            managerFee: this.tokenSwapInfo.managerFee,\n            tickSpace: this.tokenSwapInfo.tickSpace,\n            currentSqrtPrice: this.tokenSwapInfo.currentSqrtPrice,\n            currentLiquity: this.tokenSwapInfo.currentLiquity,\n            feeGrowthGlobal0: this.tokenSwapInfo.feeGrowthGlobal0,\n            feeGrowthGlobal1: this.tokenSwapInfo.feeGrowthGlobal1,\n            managerFeeA: this.tokenSwapInfo.managerFeeA,\n            managerFeeB: this.tokenSwapInfo.managerFeeB,\n          },\n          positions: Object.fromEntries(this.positions),\n          positionsKeys: Object.fromEntries(this.positionsKeys),\n          ticks: this.ticks,\n        },\n        null,\n        4\n      )\n    );\n  }\n}\n"],"names":["calculateLiquity","tickLower","tickUpper","desiredAmountSrc","currentSqrtPrice","direct","invariant","lowerSqrtPrice","tick2SqrtPrice","upperSqrtPrice","greaterThanOrEqualTo","lessThanOrEqualTo","one","Decimal","deltaLiquity","div","sub","desiredAmountDst","mul","calculateTokenAmount","liquity","lessThan","amountA","amountB","greaterThan","calculateLiquityOnlyA","desiredAmountA","calculateLiquityOnlyB","desiredAmountB","PIECES","PRICE_OFFSET","MAX_PRICE","pow","add","MIN_PRICE","MAX_SQRT_PRICE","MAX_TICK","toDP","MIN_SQRT_PRICE","MIN_TICK","sqrtPrice2Tick","sqrtPrice","log","ROUND_HALF_UP","toNumber","tick","price2Tick","price","getNearestTickBySqrtPrice","tickSpace","t","m","getNearestTickByPrice","calculateSwapA2B","ticks","fee","currentLiquity","amountIn","length","tickPrice","out","remind","remindWithFee","feeUsed","amountUsed","i","equals","liquityNet","maxAmountIn","maxAmountA","fullStepFee","ROUND_DOWN","swapA2B","ROUND_UP","amountOut","afterSqrtPrice","afterPrice","afterLiquity","maxAmountB","calculateSwapB2A","swapB2A","delta_increase","config","precision","rounding","toExpNeg","toExpPos","TokenSwapInstruction","TEN","P64","MAX_INT64","MIN_INT64","neg","MAX_UINT64","MAX_INT128","MIN_INT128","MAX_UINT128","DecimalExt","from64Buffer","buffer","Math","abs","console","ss","push","toString","slice","bn","BN","join","fromU64Buffer","from128Buffer","fromU128Buffer","to64Buffer","v","round","isNeg","toBuffer","forEach","item","index","input","toU64Buffer","to128Buffer","toU128Buffer","encodeDecode","layout","decode","bind","encode","publicKey","property","blob","publicKeyLayout","offset","src","PublicKey","decimalU64","_decode","_encode","decimalU64Layout","Buffer","from","decimal","decimal128","decimal128Layout","decimalU128","decimalU128Layout","PositionLayout","struct","s32","PositionsAccountLayout","u8","POSITIONS_ACCOUNT_SIZE","MAX_ACCOUNT_POSITION_LENGTH","floor","span","isPositionsAccount","info","data","readUInt8","parsePositionsAccount","pubkey","swapVersion","tokenSwapKey","accountType","len","positionsBuffer","dataFlat","positions","seq","TickLayout","isTicksAccount","parseTicksAccount","Layout","ticksBuffer","TokenSwapAccountLayout","u32","TOKEN_SWAP_ACCOUNT_SIZE","isTokenSwapAccount","parseTokenSwapAccount","runtime","exports","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","method","arg","Error","undefined","done","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","resolve","reject","invoke","result","__await","then","unwrapped","error","TypeError","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","DataLayout","claimInstruction","programId","authority","userTransferAuthority","swapTokenA","swapTokenB","userTokenA","userTokenB","nftMint","nftUser","ticksKey","positionsKey","positionIndex","alloc","instruction","Claim","TransactionInstruction","isSigner","isWritable","TOKEN_PROGRAM_ID","depositAllTokenTypesInstruction","isNewPosition","liquityAmount","maximumTokenA","maximumTokenB","DepositAllTokenTypes","initializeInstruction","manager","managerTokenA","managerTokenB","nonce","curveType","managerFee","Initialize","feeGrowthGlobal0","feeGrowthGlobal1","managerFeeA","managerFeeB","managerClaimInstruction","ManagerClaim","simulateSwapInstruction","direction","SimulateSwap","swapInstruction","userSource","userDestination","swapSource","swapDestination","minimumAmountOut","Swap","withdrawAllTokenTypesInstruction","minimumTokenA","minimumTokenB","WithdrawAllTokenTypes","chooseCluster","dotenv","process","env","LIVE","CLUSTER","cluster","url","RPC_URL","clusterApiUrl","urlTls","walletUrl","WALLET_URL","sendAndConfirmTransaction","conn","transaction","signers","realSendAndConfirmTransaction","skipPreflight","commitment","preflightCommitment","getAssociatedTokenAddress","tokenMint","owner","Token","ASSOCIATED_TOKEN_PROGRAM_ID","createAssociatedTokenAccountInstruction","associatedAccount","payer","address","getAccountInfo","account","accountInfo","parseTokenAccount","getTokenAccounts","getTokenAccountsByOwner","accounts","accountInfos","AccountLayout","mint","amount","u64","fromBuffer","delegateOption","delegatedAmount","isInitialized","isFrozen","isNativeOption","rentExemptReserve","isNative","closeAuthority","closeAuthorityOption","INIT_KEY","ROUND_HALF_DOWN","TokenSwap","version","tokenProgramId","tokenAMint","tokenBMint","Map","positionsKeys","setDefaultPayer","load","encoding","filters","memcmp","bytes","toBase58","getProgramAccounts","map","_this","tokenSwapInfo","set","p","nftTokenId","positionId","lowerTick","upperTick","feeGrowthInsideALast","feeGrowthInsideBLast","tokenAFee","tokenBFee","findProgramAddress","isLoaded","currentTick","createTokenSwap","initializePrice","isDebug","tokenSwapAccount","Keypair","generate","ticksAccount","positionsAccount","getMinimumBalanceForRentExemption","ticksAccountLamports","positionsAccountLarports","tokenSwapAccountLamports","Transaction","SystemProgram","createAccount","fromPubkey","newAccountPubkey","lamports","space","sqrt","tokenA","tokenB","getOrCreateAssociatedAccountInfo","tx","mintPosition","maximumAmountA","maximumAmountB","userTransferAuthroity","nftMintAccount","getMinBalanceRentForExemptAccount","accountLamports","choosePosition","MintLayout","createInitMintInstruction","increaseLiquity","positionInfo","getPositionInfo","nftToken","decreaseLiquity","minimumAmountA","minimumAmountB","swap","swapSrc","swapDst","simulateSwap","simulateTransaction","collect","managerCollect","addPositionsAccount","AddUserPosition","approve","userToken","token","getUserPositions","_this$payer","tokenAccounts","position","get","calculateLiquityByTokenA","res","calculateLiquityByTokenB","calculatePositionValue","preCollect","lowerFeeOutSideA","lowerFeeOutSideB","upperFeeOutSideA","upperFeeOutSideB","feeGrowthOutside0","feeGrowthOutside1","preSwapA","currentPriceA","currentPriceB","transactionPriceA","transactionPriceB","impactA","impactB","afterPriceA","afterPriceB","preSwapB","JSON","stringify","currentPrice","fromEntries","minLiquity","maxLiquity","liquitys","slid","maxSqrtPrice","minSqrtPrice","constant","minRes","maxRes","minAmountA","minAmountB","decimal64Layout"],"mappings":"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"}